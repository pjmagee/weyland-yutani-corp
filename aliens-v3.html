<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Alien Franchise — DAG (Scoped + Node Sources)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, Segoe UI, Arial
    }

    .topbar {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #e5e5e5;
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 2;
    }

    .title {
      font-weight: 600;
    }

    select {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #bbb;
      font-size: 13px;
    }

    .wrap {
      height: calc(100vh - 52px);
    }

    #viz {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
    }

    /* Node base shapes */
    .node circle,
    .node rect,
    .node polygon {
      stroke: #222;
      stroke-width: 1.4;
      vector-effect: non-scaling-stroke;
    }

    /* Label styling with white halo for readability */
    .node .label {
      font-size: 12px;
      font-weight: 600;
      dominant-baseline: middle;
      text-anchor: middle;
      paint-order: stroke fill;
      stroke: #fff;
      stroke-width: 3px;
      fill: #111;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Background behind labels to prevent line overlap (adds an opaque panel behind text) */
    .node .label-bg {
      fill: #fff;
      stroke: #ddd;
      stroke-width: 1;
    }

    /* Link icon next to label */
    .node .link-icon {
      font-size: 12px;
      dominant-baseline: middle;
      fill: #1976d2;
      paint-order: stroke fill;
      stroke: #fff;
      stroke-width: 2px;
      cursor: pointer;
    }

    .node a {
      text-decoration: none;
    }

    /* Links */
    .link {
      fill: none;
      stroke: #888;
      stroke-width: 1.4;
    }

    .link.back {
      stroke-dasharray: 4 3;
      stroke: #aaa;
    }

    .edge-label {
      font-size: 11px;
      fill: #111;
      -webkit-user-select: none;
      user-select: none;
      paint-order: stroke fill;
      stroke: #fff;
      stroke-width: 2px;
    }

    .tip {
      position: fixed;
      pointer-events: none;
      background: #111;
      color: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      opacity: 0;
      transition: opacity .12s;
      max-width: 360px;
      z-index: 10;
    }

    .tip a {
      color: #9ad;
      text-decoration: underline;
    }

    .pill {
      display: inline-block;
      border: 1px solid #777;
      border-radius: 999px;
      padding: 1px 6px;
      font-size: 11px;
      background: #fff;
      color: #333;
      margin: 2px 4px 0 0;
    }

    .notice {
      color: #b00;
      font-size: 12px
    }

    /* Overlay panel */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.25);
      display: none;
      z-index: 5;
    }

    .overlay.show {
      display: block;
    }

    .panel {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      width: min(440px, 90vw);
      background: #fff;
      box-shadow: -2px 0 12px rgba(0, 0, 0, 0.15);
      padding: 16px 16px 24px;
      overflow: auto;
    }

    .panel .close {
      position: absolute;
      top: 8px;
      right: 8px;
      border: none;
      background: transparent;
      font-size: 22px;
      cursor: pointer;
      line-height: 1;
      padding: 4px;
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 18px;
    }

    .panel .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .panel .meta .pill {
      margin: 0;
    }

    .panel .src {
      margin: 6px 0 12px;
      font-size: 13px;
    }

    .panel .src a {
      color: #1976d2;
      text-decoration: underline;
    }

    .panel .thumb {
      margin: 8px 0 12px;
    }

    .panel .thumb img {
      max-width: 100%;
      height: auto;
      border-radius: 6px;
      border: 1px solid #ddd;
    }

    .panel .body {
      font-size: 14px;
      line-height: 1.45;
      color: #222;
      white-space: pre-wrap;
    }

    .panel .loading {
      color: #666;
      font-style: italic;
    }

    .topbar .lbl-toggle {
      margin-left: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="title">Alien Franchise — DAG</div>
    <label for="rootSel">Root:</label>
    <select id="rootSel" aria-label="Choose root"></select>
    <div id="status" class="notice"></div>
  </div>
  <div class="wrap">
    <svg id="viz"></svg>
  </div>
  <div id="tip" class="tip"></div>
  <!-- Removed right-side overlay; details now appear inside a persistent tooltip on click -->
  <script>
    // Embedded single source of truth (film canon only; no AVP). Now with per-node SOURCE links.
    const DATA = {
      title: "Alien Franchise — Cohesive Lifecycle Overview (Film Canon only; no AVP)",
      scope: "Classic hive, Engineer pathogen branches, and experimental lines (Resurrection, Romulus).",
      roots: ["Queen", "Facehugger", "Black Goo", "Cloned Queen (human DNA)"],
      // Reference index (not used directly for tooltips; see SOURCES map below)
      sources: [
        { title: "Ovomorph", url: "https://alienanthology.fandom.com/wiki/Ovomorph" },
        { title: "Facehugger", url: "https://alienanthology.fandom.com/wiki/Facehugger" },
        { title: "Chestburster", url: "https://alienanthology.fandom.com/wiki/Chestburster" },
        { title: "Drone", url: "https://alienanthology.fandom.com/wiki/Drone" },
        { title: "Soldier/Warrior", url: "https://alienanthology.fandom.com/wiki/Soldier" },
        { title: "Runner", url: "https://alienanthology.fandom.com/wiki/Runner" },
        { title: "Praetorian / Royal Guard (concept)", url: "https://alienanthology.fandom.com/wiki/Royal_Guard" },
        { title: "Queen", url: "https://alienanthology.fandom.com/wiki/Queen" },
        { title: "Chemical A0-3959X.91–15 (Black Goo)", url: "https://alienanthology.fandom.com/wiki/Chemical_A0-3959X.91_%E2%80%93_15" },
        { title: "Hammerpede", url: "https://alienanthology.fandom.com/wiki/Hammerpede" },
        { title: "Trilobite", url: "https://alienanthology.fandom.com/wiki/The_Trilobite" },
        { title: "The Deacon", url: "https://alienanthology.fandom.com/wiki/The_Deacon" },
        { title: "Protomorph", url: "https://alienanthology.fandom.com/wiki/Protomorph" },
        { title: "Alien: Covenant", url: "https://alienanthology.fandom.com/wiki/Alien:_Covenant" },
        { title: "Alien", url: "https://alienanthology.fandom.com/wiki/Alien" },
        { title: "Alien: Resurrection", url: "https://alienanthology.fandom.com/wiki/Alien:_Resurrection" },
        { title: "Cloned Queen", url: "https://alienanthology.fandom.com/wiki/Cloned_Queen" },
        { title: "The Newborn", url: "https://alienanthology.fandom.com/wiki/The_Newborn" },
        { title: "Kay Harrison", url: "https://alienanthology.fandom.com/wiki/Kay_Harrison" }
      ],
      nodes: [
        { id: "Human", type: "host" },
        { id: "Dog", type: "host" },
        { id: "Ox", type: "host" },
        { id: "Engineer", type: "host" },
        { id: "Pregnant Human", type: "host" },
        { id: "Worms", type: "host" },
        { id: "Ellen Ripley (DNA)", type: "artifact" },

        { id: "Egg (Ovomorph)", type: "artifact" },
        { id: "Cocooned Victim", type: "artifact" },
        { id: "Pods (contaminated)", type: "artifact" },
        { id: "Protomorph Egg", type: "artifact" },

        { id: "Spores / Motes", type: "vector" },

        { id: "Facehugger", type: "stage" },
        { id: "Royal Facehugger", type: "stage" },
        { id: "Chestburster", type: "stage" },
        { id: "Bloodburster", type: "stage" },
        { id: "Proto-Facehugger", type: "stage" },

        { id: "Drone", type: "species" },
        { id: "Warrior", type: "species" },
        { id: "Runner", type: "species" },
        { id: "Praetorian", type: "stage" },
        { id: "Queen", type: "species" },
        { id: "Neomorph", type: "species" },
        { id: "Protomorph", type: "species" },
        { id: "Deacon", type: "species" },

        { id: "Newborn", type: "hybrid" },
        { id: "Cloned Queen (human DNA)", type: "species" },

        { id: "Black Goo", type: "agent" },
        { id: "Infected Human", type: "organism" },
        { id: "Trilobite", type: "organism" },
        { id: "Hammerpede", type: "organism" },
        { id: "Offspring", type: "organism" }
      ],
      processes: [
        { id: "Lay Egg", kind: "reproduction" },
        { id: "Hatch Normal", kind: "maturation" },
        { id: "Hatch Royal", kind: "maturation" },
        { id: "Egg Morphing", kind: "biogenesis" },

        { id: "Implantation: Facehugger + Human", kind: "implantation" },
        { id: "Implantation: Facehugger + Dog", kind: "implantation" },
        { id: "Implantation: Facehugger + Ox", kind: "implantation" },
        { id: "Royal Implantation (Queen embryo)", kind: "implantation" },

        { id: "Mature (Human host)", kind: "maturation" },
        { id: "Mature (Quadruped host)", kind: "maturation" },

        { id: "Evolve: Drone → Praetorian", kind: "evolution" },
        { id: "Evolve: Praetorian → Queen", kind: "evolution" },

        { id: "Black Goo + Human", kind: "infection" },
        { id: "Parasitic transfer (sexual)", kind: "transmission" },
        { id: "Trilobite + Engineer", kind: "impregnation" },
        { id: "Black Goo + Ecosystem", kind: "contaminate" },
        { id: "Pods release Spores", kind: "release" },
        { id: "Spores infect Human", kind: "infection" },
        { id: "Bloodburster → Neomorph", kind: "maturation" },

        { id: "Experimental line", kind: "experiment" },
        { id: "Hatch (Proto)", kind: "maturation" },
        { id: "Implantation: Proto-Facehugger + Human", kind: "implantation" },
        { id: "Mature (Proto host)", kind: "maturation" },

        { id: "Cloning (Resurrection)", kind: "cloning" },
        { id: "Queen live birth (clone context)", kind: "anomalous" },

        { id: "Black Goo + Worms", kind: "infection" }
      ],
      links: [
        { source: "Queen", target: "Lay Egg", kind: "reproduction" },
        { source: "Lay Egg", target: "Egg (Ovomorph)", kind: "reproduction" },
        { source: "Egg (Ovomorph)", target: "Hatch Normal", kind: "maturation" },
        { source: "Hatch Normal", target: "Facehugger", kind: "maturation" },
        { source: "Egg (Ovomorph)", target: "Hatch Royal", kind: "maturation" },
        { source: "Hatch Royal", target: "Royal Facehugger", kind: "maturation" },

        { source: "Royal Facehugger", target: "Royal Implantation (Queen embryo)", kind: "implantation" },
        { source: "Human", target: "Royal Implantation (Queen embryo)", kind: "host" },
        { source: "Royal Implantation (Queen embryo)", target: "Chestburster", kind: "implantation" },
        { source: "Chestburster", target: "Queen", kind: "maturation" },

        { source: "Facehugger", target: "Implantation: Facehugger + Human", kind: "implantation" },
        { source: "Human", target: "Implantation: Facehugger + Human", kind: "host" },
        { source: "Implantation: Facehugger + Human", target: "Chestburster", kind: "implantation" },
        { source: "Chestburster", target: "Mature (Human host)", kind: "maturation" },
        { source: "Mature (Human host)", target: "Drone", kind: "maturation" },
        { source: "Mature (Human host)", target: "Warrior", kind: "maturation" },

        { source: "Facehugger", target: "Implantation: Facehugger + Dog", kind: "implantation" },
        { source: "Dog", target: "Implantation: Facehugger + Dog", kind: "host" },
        { source: "Implantation: Facehugger + Dog", target: "Chestburster", kind: "implantation" },

        { source: "Facehugger", target: "Implantation: Facehugger + Ox", kind: "implantation" },
        { source: "Ox", target: "Implantation: Facehugger + Ox", kind: "host" },
        { source: "Implantation: Facehugger + Ox", target: "Chestburster", kind: "implantation" },

        { source: "Chestburster", target: "Mature (Quadruped host)", kind: "maturation" },
        { source: "Mature (Quadruped host)", target: "Runner", kind: "maturation" },

        { source: "Drone", target: "Evolve: Drone → Praetorian", kind: "evolution" },
        { source: "Evolve: Drone → Praetorian", target: "Praetorian", kind: "evolution" },
        { source: "Praetorian", target: "Evolve: Praetorian → Queen", kind: "evolution" },
        { source: "Evolve: Praetorian → Queen", target: "Queen", kind: "evolution" },

        { source: "Drone", target: "Egg Morphing", kind: "biogenesis" },
        { source: "Cocooned Victim", target: "Egg Morphing", kind: "biogenesis" },
        { source: "Egg Morphing", target: "Egg (Ovomorph)", kind: "biogenesis" },

        { source: "Black Goo", target: "Black Goo + Human", kind: "infection" },
        { source: "Human", target: "Black Goo + Human", kind: "host" },
        { source: "Black Goo + Human", target: "Infected Human", kind: "infection" },
        { source: "Infected Human", target: "Parasitic transfer (sexual)", kind: "transmission" },
        { source: "Parasitic transfer (sexual)", target: "Trilobite", kind: "parasite" },
        { source: "Trilobite", target: "Trilobite + Engineer", kind: "impregnation" },
        { source: "Engineer", target: "Trilobite + Engineer", kind: "host" },
        { source: "Trilobite + Engineer", target: "Deacon", kind: "reproduction" },

        { source: "Black Goo", target: "Black Goo + Ecosystem", kind: "contaminate" },
        { source: "Black Goo + Ecosystem", target: "Pods (contaminated)", kind: "contaminate" },
        { source: "Pods (contaminated)", target: "Pods release Spores", kind: "release" },
        { source: "Pods release Spores", target: "Spores / Motes", kind: "release" },
        { source: "Spores / Motes", target: "Spores infect Human", kind: "infection" },
        { source: "Human", target: "Spores infect Human", kind: "host" },
        { source: "Spores infect Human", target: "Bloodburster", kind: "infection" },
        { source: "Bloodburster", target: "Bloodburster → Neomorph", kind: "maturation" },
        { source: "Bloodburster → Neomorph", target: "Neomorph", kind: "maturation" },

        { source: "Black Goo", target: "Experimental line", kind: "experiment" },
        { source: "Experimental line", target: "Protomorph Egg", kind: "experiment" },
        { source: "Protomorph Egg", target: "Hatch (Proto)", kind: "maturation" },
        { source: "Hatch (Proto)", target: "Proto-Facehugger", kind: "maturation" },
        { source: "Proto-Facehugger", target: "Implantation: Proto-Facehugger + Human", kind: "implantation" },
        { source: "Human", target: "Implantation: Proto-Facehugger + Human", kind: "host" },
        { source: "Implantation: Proto-Facehugger + Human", target: "Chestburster", kind: "implantation" },
        { source: "Chestburster", target: "Mature (Proto host)", kind: "maturation" },
        { source: "Mature (Proto host)", target: "Protomorph", kind: "maturation" },

        { source: "Black Goo", target: "Black Goo + Worms", kind: "infection" },
        { source: "Worms", target: "Black Goo + Worms", kind: "host" },
        { source: "Black Goo + Worms", target: "Hammerpede", kind: "infection" },

        { source: "Black Goo", target: "Experimental line", kind: "experiment" },
        { source: "Pregnant Human", target: "Experimental line", kind: "host" },
        { source: "Experimental line", target: "Offspring", kind: "result" },

        { source: "Queen", target: "Cloning (Resurrection)", kind: "cloning" },
        { source: "Human", target: "Cloning (Resurrection)", kind: "cloning" },
        { source: "Cloning (Resurrection)", target: "Cloned Queen (human DNA)", kind: "cloning" },
        { source: "Ellen Ripley (DNA)", target: "Cloning (Resurrection)", kind: "cloning" },
        { source: "Cloned Queen (human DNA)", target: "Queen live birth (clone context)", kind: "anomalous" },
        { source: "Queen live birth (clone context)", target: "Newborn", kind: "anomalous" }
      ],
      finalProducts: [
        "Drone", "Warrior", "Runner", "Queen", "Neomorph", "Protomorph", "Deacon", "Hammerpede", "Offspring", "Newborn"
      ]
    };

    // Per-ID canonical source links (Alien Anthology Wiki preferred; one reliable external for egg morphing context)
    const SOURCES = {
      // Hosts and vectors/artifacts
      "Human": "https://alienanthology.fandom.com/wiki/Human",
      "Dog": "https://alienanthology.fandom.com/wiki/Alien_%C2%B3",
      "Ox": "https://alienanthology.fandom.com/wiki/Alien_%C2%B3",
      "Engineer": "https://alienanthology.fandom.com/wiki/Engineer",
      "Pregnant Human": "https://alienanthology.fandom.com/wiki/Alien:_Romulus",
      "Worms": "https://alienanthology.fandom.com/wiki/Prometheus",
      "Egg (Ovomorph)": "https://alienanthology.fandom.com/wiki/Ovomorph",
      "Cocooned Victim": "https://alienanthology.fandom.com/wiki/Ovomorph",
      "Pods (contaminated)": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Protomorph Egg": "https://alienanthology.fandom.com/wiki/Protomorph",
      "Spores / Motes": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",

      // Stages and species
      "Facehugger": "https://alienanthology.fandom.com/wiki/Facehugger",
      "Royal Facehugger": "https://alienanthology.fandom.com/wiki/Queen",
      "Chestburster": "https://alienanthology.fandom.com/wiki/Chestburster",
      "Bloodburster": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Proto-Facehugger": "https://alienanthology.fandom.com/wiki/Protomorph",

      "Drone": "https://alienanthology.fandom.com/wiki/Drone",
      "Warrior": "https://alienanthology.fandom.com/wiki/Soldier",
      "Runner": "https://alienanthology.fandom.com/wiki/Runner",
      "Praetorian": "https://alienanthology.fandom.com/wiki/Royal_Guard",
      "Queen": "https://alienanthology.fandom.com/wiki/Queen",
      "Neomorph": "https://avp.fandom.com/wiki/Neomorph",
      "Protomorph": "https://alienanthology.fandom.com/wiki/Protomorph",
      "Deacon": "https://alienanthology.fandom.com/wiki/The_Deacon",

      "Newborn": "https://alienanthology.fandom.com/wiki/The_Newborn",
      "Cloned Queen (human DNA)": "https://alienanthology.fandom.com/wiki/Cloned_Queen",

      // Agents/organisms
      "Black Goo": "https://alienanthology.fandom.com/wiki/Chemical_A0-3959X.91_%E2%80%93_15",
      "Infected Human": "https://alienanthology.fandom.com/wiki/Prometheus",
      "Trilobite": "https://alienanthology.fandom.com/wiki/The_Trilobite",
      "Hammerpede": "https://alienanthology.fandom.com/wiki/Hammerpede",
      "Offspring": "https://alienanthology.fandom.com/wiki/Alien:_Romulus",
      "Ellen Ripley (DNA)": "https://alienanthology.fandom.com/wiki/Ellen_Ripley",

      // Processes (link to best canonical discussion)
      "Lay Egg": "https://alienanthology.fandom.com/wiki/Ovomorph",
      "Hatch Normal": "https://alienanthology.fandom.com/wiki/Facehugger",
      "Hatch Royal": "https://alienanthology.fandom.com/wiki/Queen",
      "Egg Morphing": "https://en.wikipedia.org/wiki/Xenomorph#Egg",
      "Implantation: Facehugger + Human": "https://alienanthology.fandom.com/wiki/Facehugger",
      "Implantation: Facehugger + Dog": "https://alienanthology.fandom.com/wiki/Alien_%C2%B3",
      "Implantation: Facehugger + Ox": "https://alienanthology.fandom.com/wiki/Alien_%C2%B3",
      "Royal Implantation (Queen embryo)": "https://alienanthology.fandom.com/wiki/Queen",
      "Mature (Human host)": "https://alienanthology.fandom.com/wiki/Xenomorph_XX121",
      "Mature (Quadruped host)": "https://alienanthology.fandom.com/wiki/Runner",
      "Evolve: Drone → Praetorian": "https://alienanthology.fandom.com/wiki/Royal_Guard",
      "Evolve: Praetorian → Queen": "https://alienanthology.fandom.com/wiki/Queen",
      "Black Goo + Human": "https://alienanthology.fandom.com/wiki/Chemical_A0-3959X.91_%E2%80%93_15",
      "Parasitic transfer (sexual)": "https://alienanthology.fandom.com/wiki/Prometheus",
      "Trilobite + Engineer": "https://alienanthology.fandom.com/wiki/Prometheus",
      "Black Goo + Ecosystem": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Pods release Spores": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Spores infect Human": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Bloodburster → Neomorph": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Experimental line": "https://alienanthology.fandom.com/wiki/Alien:_Covenant",
      "Hatch (Proto)": "https://alienanthology.fandom.com/wiki/Protomorph",
      "Implantation: Proto-Facehugger + Human": "https://alienanthology.fandom.com/wiki/Protomorph",
      "Mature (Proto host)": "https://alienanthology.fandom.com/wiki/Protomorph",
      "Cloning (Resurrection)": "https://alienanthology.fandom.com/wiki/Alien:_Resurrection",
      "Queen live birth (clone context)": "https://alienanthology.fandom.com/wiki/The_Newborn",
      "Black Goo + Worms": "https://alienanthology.fandom.com/wiki/Prometheus"
    };

    // Curated, canon-safe descriptions for select nodes (avoids relying on AVP wiki while keeping Covenant facts)
    const DESCRIPTIONS = {
      "Egg (Ovomorph)": "A leathery ovum that houses a Facehugger. Canon depicts two creation routes: (1) primary—laid by a Queen in a hive; (2) fallback—formed via egg morphing when no Queen is present (Alien 1979 Director's Cut). The derelict egg caches' ultimate origin is left ambiguous, while prequel material shows engineered seeding via the pathogen.",
      "Lay Egg": "Queen-led reproduction: the Queen produces Ovomorphs in quantity within a hive; each typically contains a Facehugger (Aliens).",
      "Egg Morphing": "Fallback biogenesis observed in Alien (1979, Director's Cut): a cocooned host is transformed into an Ovomorph housing a Facehugger when no Queen is available.",
      "Pods (contaminated)": "Fungal seed pods (often called small 'spore sacs' in materials) that formed on Planet 4 when the Engineer pathogen (\"black goo\") contaminated the local ecosystem. They are not Xenomorph eggs. Physical disturbance causes the pods to rupture.",
      "Pods release Spores": "When disturbed, the small pods/spore sacs burst and aerosolize microscopic motes that drift on air currents.",
      "Spores / Motes": "Airborne motes released by small fungus-like pods (spore sacs) on Planet 4 following black goo contamination. The motes penetrate soft tissues (e.g., ear canal) and parasitize human hosts, producing Bloodbursters that rapidly mature into Neomorphs (as with Ledward and Hallett in Alien: Covenant).",
      "Protomorph Egg": "Artificial ova cultured by David using the Engineer pathogen and local biomatter (Alien: Covenant). These are not natural queen-laid eggs; they house a fast-acting facehugger variant used to implant hosts in David's lab.",
      "Proto-Facehugger": "Also called a protohugger in some materials, this facehugger variant emerges from Protomorph eggs in David's lab and rapidly implants a human host, yielding a chestburster that matures into a Protomorph (Alien: Covenant).",
      "Hatch (Proto)": "Emergence of the protohugger from a Protomorph egg in David's chamber (Alien: Covenant).",
      "Implantation: Proto-Facehugger + Human": "Protohugger attaches and implants a human host extremely quickly in Alien: Covenant, leading to a distinct chestburster stage.",
      "Mature (Proto host)": "The proto chestburster rapidly matures into the adult Protomorph in Alien: Covenant.",
      "Neomorph": "A pale, spindly xenomorph-like organism produced when black goo–generated motes from small fungal spore sacs/pods infect a human host (Alien: Covenant). Neomorphs do not come from queen-laid eggs or facehuggers; they arise via spores → Bloodburster → Neomorph, independent of David's engineered eggs.",
      "Ellen Ripley (DNA)": "Genetic material recovered from Ellen Ripley after her death on Fiorina 161. In Alien: Resurrection, Weyland-Yutani/USM cloned Ripley using DNA mixed with a gestating Queen embryo, producing hybridized clones.",
      "Cloning (Resurrection)": "USM program aboard the USM Auriga that cloned Ripley from mixed Human/Queen DNA. Iterative attempts resulted in several malformed clones before a successful hybrid (Ripley 8) bearing a Queen embryo was produced.",
      "Cloned Queen (human DNA)": "Queen resulting from cloning using mixed human and Xenomorph DNA. Exhibits anomalies such as a functional womb, enabling live birth within the clone context.",
      "Queen live birth (clone context)": "An anomalous reproductive event: the cloned Queen bears a live-born hybrid instead of laying eggs, resulting in the Newborn.",
      "Offspring": "A human–Xenomorph hybrid birthed by Kay Harrison after self-injecting compound Z-01 aboard the USCSS Corbelan IV (Alien: Romulus)."
    };

    // Thumbnail overrides when the wiki returns an incorrect/misleading image
    const THUMBNAIL_OVERRIDES = {
      // Prefer a creature still from Romulus for the Offspring; fall back to none if not available
      // If a proper Offspring file appears later, update this URL accordingly.
      "Offspring": null,
      // Ensure pods and motes show the correct Covenant visuals (AVP Fandom/Xenopedia files)
      "Pods (contaminated)": "https://static.wikia.nocookie.net/avp/images/a/ad/Egg_sack.png/revision/latest?cb=20170520193859",
      "Spores / Motes": "https://static.wikia.nocookie.net/avp/images/8/8a/Motes.png/revision/latest?cb=20170520193934",
      // Bloodburster visual from Covenant
      "Bloodburster": "https://static.wikia.nocookie.net/avp/images/6/60/Baby_Neomorph_attacking_pose.png/revision/latest/scale-to-width-down/615?cb=20170707154425"
    };

    const edgeLabel = (kind) => ({ reproduction: 'lays/produces', maturation: 'matures', implantation: 'implants', host: 'host', evolution: 'evolves', infection: 'infects', contaminate: 'contaminates', release: 'releases', parasite: 'parasitic outcome', biogenesis: 'forms egg', experiment: 'experiment', anomalous: 'anomalous birth', origin: 'origin', impregnation: 'impregnates', result: 'result', transmission: 'transmission', cloning: 'cloning' })[kind] || kind;

    // Soft colors by node type
    const typeFill = {
      host: '#e7f1ff',
      artifact: '#fff7db',
      vector: '#fff0c2',
      stage: '#f3f6f9',
      species: '#e9f7ef',
      hybrid: '#f9e6ef',
      agent: '#efefef',
      organism: '#f1f8ff',
      process: '#fbecff'
    };

    const svg = d3.select('#viz');
    const g = svg.append('g');
    const linkG = g.append('g');
    const nodeG = g.append('g');
    const tip = document.getElementById('tip');
    const status = document.getElementById('status');
    const rootSel = document.getElementById('rootSel');

    function getSize() { const w = window.innerWidth; const h = window.innerHeight - 52; return { width: Math.max(960, w), height: Math.max(600, h) }; }
    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }[c])); }

    const zoom = d3.zoom().scaleExtent([0.3, 2]).on('zoom', (ev) => { g.attr('transform', ev.transform); });
    svg.call(zoom);

    window.addEventListener('resize', () => currentData && render(currentData, rootSel.value));
    function truncate(s, n) { s = String(s); return s.length > n ? s.slice(0, n - 1) + '…' : s; }

    // Attach SOURCE URLs to nodes and process nodes
    function withSources(d) {
      const copy = JSON.parse(JSON.stringify(d));
      (copy.nodes || []).forEach(n => { if (SOURCES[n.id]) n.source = SOURCES[n.id]; });
      (copy.processes || []).forEach(p => { if (SOURCES[p.id]) p.source = SOURCES[p.id]; });
      return copy;
    }

    let currentData = withSources(DATA);

    // Build combined node list (include processes as nodes and carry source property)
    function combinedNodes(d) {
      const ps = (d.processes || []).map(p => ({ id: p.id, type: 'process', source: p.source }));
      return [...(d.nodes || []), ...ps];
    }
    // Prepare target list: all species/hybrids + any finalProducts (e.g., Hammerpede, Offspring)
    function targetList(d) {
      const ids = new Set();
      const list = [];
      (d.nodes || []).forEach(n => { if (n.type === 'species' || n.type === 'hybrid') { ids.add(n.id); list.push(n.id); } });
      (d.finalProducts || []).forEach(id => { if (!ids.has(id)) { ids.add(id); list.push(id); } });
      return list;
    }
    // Maps
    function buildMaps(d) {
      const nodesAll = combinedNodes(d);
      const nodeMap = new Map(nodesAll.map(n => [n.id, n]));
      const out = new Map(); const inc = new Map();
      (d.links || []).forEach(e => {
        if (!nodeMap.has(e.source) || !nodeMap.has(e.target)) return;
        if (!out.has(e.source)) out.set(e.source, []); out.get(e.source).push(e);
        if (!inc.has(e.target)) inc.set(e.target, []); inc.get(e.target).push(e);
      });
      return { nodesAll, nodeMap, out, inc };
    }

    // Lineage-aware filtering
    const CLASSIC = new Set(['Drone', 'Warrior', 'Runner', 'Queen']);
    const PROTO = new Set(['Protomorph']);
    const NEWBORN = new Set(['Newborn']);
    const PATHOGEN = new Set(['Neomorph', 'Deacon', 'Hammerpede']);

    function allowedPredicateForTarget(targetId) {
      // Clone-line scoping: include inputs and immediate anomalous outcome context
      if (targetId === 'Cloned Queen (human DNA)') {
        const allow = new Set([
          'Queen', 'Human', 'Ellen Ripley (DNA)', 'Cloning (Resurrection)', 'Cloned Queen (human DNA)',
          'Queen live birth (clone context)', 'Newborn'
        ]);
        return id => allow.has(id);
      }
      if (CLASSIC.has(targetId)) {
        if (targetId === 'Runner') {
          const allow = new Set([
            'Dog', 'Ox', 'Cocooned Victim',
            'Egg (Ovomorph)', 'Facehugger', 'Chestburster',
            'Mature (Quadruped host)',
            'Lay Egg', 'Egg Morphing', 'Hatch Normal',
            'Implantation: Facehugger + Dog', 'Implantation: Facehugger + Ox',
            'Runner'
          ]);
          return id => allow.has(id);
        }
        if (targetId === 'Queen') {
          const allow = new Set([
            'Human', 'Cocooned Victim',
            'Egg (Ovomorph)', 'Facehugger', 'Royal Facehugger', 'Chestburster', 'Praetorian',
            'Lay Egg', 'Egg Morphing', 'Hatch Normal', 'Hatch Royal',
            'Royal Implantation (Queen embryo)',
            'Evolve: Drone → Praetorian', 'Evolve: Praetorian → Queen',
            'Queen'
          ]);
          return id => allow.has(id);
        }
        const allow = new Set([
          'Human', 'Cocooned Victim',
          'Egg (Ovomorph)', 'Facehugger', 'Chestburster',
          'Lay Egg', 'Egg Morphing', 'Hatch Normal',
          'Implantation: Facehugger + Human',
          'Mature (Human host)',
          'Drone', 'Warrior'
        ]);
        return id => allow.has(id);
      }
      if (PROTO.has(targetId)) {
        const allow = new Set([
          'Black Goo', 'Human', 'Chestburster',
          'Experimental line', 'Protomorph Egg', 'Hatch (Proto)', 'Proto-Facehugger',
          'Implantation: Proto-Facehugger + Human', 'Mature (Proto host)', 'Protomorph'
        ]);
        return id => allow.has(id);
      }
      if (NEWBORN.has(targetId)) {
        const allow = new Set([
          'Queen', 'Human', 'Cloning (Resurrection)', 'Cloned Queen (human DNA)',
          'Queen live birth (clone context)', 'Newborn'
        ]);
        return id => allow.has(id);
      }
      if (PATHOGEN.has(targetId)) {
        if (targetId === 'Neomorph') {
          const allow = new Set([
            'Black Goo', 'Black Goo + Ecosystem', 'Pods (contaminated)', 'Pods release Spores',
            'Spores / Motes', 'Spores infect Human', 'Human', 'Bloodburster', 'Bloodburster → Neomorph', 'Neomorph'
          ]);
          return id => allow.has(id);
        }
        if (targetId === 'Deacon') {
          const allow = new Set([
            'Black Goo', 'Human', 'Black Goo + Human', 'Infected Human', 'Parasitic transfer (sexual)',
            'Trilobite', 'Engineer', 'Trilobite + Engineer', 'Deacon'
          ]);
          return id => allow.has(id);
        }
        if (targetId === 'Hammerpede') {
          const allow = new Set([
            'Black Goo', 'Worms', 'Black Goo + Worms', 'Hammerpede'
          ]);
          return id => allow.has(id);
        }
      }
      if (targetId === 'Offspring') {
        const allow = new Set([
          'Black Goo', 'Pregnant Human', 'Experimental line', 'Offspring'
        ]);
        return id => allow.has(id);
      }
      return _ => true;
    }

    function buildSubgraph(d, targetId) {
      const { nodeMap, out, inc } = buildMaps(d);
      if (!nodeMap.has(targetId)) return { nodes: [], links: [] };
      const allow = allowedPredicateForTarget(targetId);
      if (!allow(targetId)) return { nodes: [], links: [] };
      const nodesSet = new Set([targetId]);
      const edges = [];
      const q = [targetId];
      while (q.length) {
        const v = q.shift();
        const ins = inc.get(v) || [];
        for (const e of ins) {
          if (!allow(e.source) || !allow(e.target)) continue;
          edges.push(e);
          if (!nodesSet.has(e.source)) { nodesSet.add(e.source); q.push(e.source); }
        }
      }
      const nodes = Array.from(nodesSet).map(id => nodeMap.get(id)).filter(Boolean);
      return { nodes, links: edges };
    }

    // Populate dropdown with targets
    const targets = targetList(currentData);
    targets.forEach((id, i) => { const opt = document.createElement('option'); opt.value = id; opt.textContent = id; if (i === 0) opt.selected = true; rootSel.appendChild(opt); });
    rootSel.addEventListener('change', () => render(currentData, rootSel.value));
    status.textContent = 'Hover to preview; click to open details. Click canvas or press Esc to close.';
    render(currentData, targets[0]);

    function showTip(d, ev) {
      const hint = '<div style="margin-top:4px;color:#ddd">Click for details</div>';
      const html = `
        <div><b>${escapeHtml(d.id)}</b></div>
        <div class="pill">${escapeHtml(d.type)}</div>
        ${hint}
      `;
      tip.innerHTML = html; tip.style.left = (ev.clientX + 12) + 'px'; tip.style.top = (ev.clientY + 12) + 'px'; tip.style.opacity = 1;
    }

    function hideTip() { tip.style.opacity = 0; }

    function render(json, target) {
      const { width, height } = getSize(); svg.attr('viewBox', `0 0 ${width} ${height}`);
      nodeG.selectAll('*').remove(); linkG.selectAll('*').remove();
      const sub = buildSubgraph(json, target);
      const nodes = sub.nodes; const links = sub.links;
      const nodeMap = new Map(nodes.map(d => [d.id, d]));
      const out = new Map(); const inc = new Map();
      links.forEach(e => { if (!out.has(e.source)) out.set(e.source, []); out.get(e.source).push(e); if (!inc.has(e.target)) inc.set(e.target, []); inc.get(e.target).push(e); });

      // Rank from sources within the subgraph
      const indeg = new Map(nodes.map(n => [n.id, 0]));
      links.forEach(e => indeg.set(e.target, (indeg.get(e.target) || 0) + 1));
      const seeds = nodes.filter(n => (indeg.get(n.id) || 0) === 0).map(n => n.id);
      const rank = new Map();
      const q = [...seeds]; seeds.forEach(s => rank.set(s, 0));
      while (q.length) {
        const u = q.shift(); const ru = rank.get(u);
        (out.get(u) || []).forEach(e => { const v = e.target; const rv = rank.has(v) ? rank.get(v) : Infinity; const nr = ru + 1; if (nr < rv) { rank.set(v, nr); q.push(v); } });
      }
      // Ensure target is rightmost
      const maxRank = Array.from(rank.values()).reduce((a, b) => Math.max(a, b), 0);
      const tRank = rank.get(target) ?? maxRank;
      const shift = (tRank < maxRank) ? (maxRank - tRank) : 0;
      if (shift) { Array.from(rank.keys()).forEach(k => rank.set(k, (rank.get(k) || 0) + shift)); }

      // layout per rank
      const layered = d3.groups(nodes, d => rank.get(d.id) ?? 0).sort((a, b) => a[0] - b[0]);
      const colW = 220; const margins = { top: 40, left: 40, right: 40, bottom: 40 };
      const xForRank = r => margins.left + r * colW;
      const layerHeights = layered.map(([rk, arr]) => ({ rk, arr, spacing: (height - margins.top - margins.bottom) / (arr.length + 1) }));
      const pos = new Map();
      layerHeights.forEach(({ rk, arr, spacing }) => {
        arr.forEach((d, i) => { const x = xForRank(rk); const y = margins.top + (i + 1) * spacing; pos.set(d.id, { x, y }); });
      });

      // draw links
      const pathFor = (a, b) => {
        const p0 = pos.get(a), p1 = pos.get(b); const mx = (p0.x + p1.x) / 2; return `M${p0.x},${p0.y} C${mx},${p0.y} ${mx},${p1.y} ${p1.x},${p1.y}`;
      };
      const linkSel = linkG.selectAll('path.link').data(links.filter(e => nodeMap.has(e.source) && nodeMap.has(e.target))).enter().append('path')
        .attr('class', e => ((rank.get(e.target) ?? 0) <= (rank.get(e.source) ?? 0)) ? 'link back' : 'link')
        .attr('d', e => pathFor(e.source, e.target));

      // arrowheads
      const defs = svg.append('defs');
      defs.append('marker').attr('id', 'arrow').attr('viewBox', '0 0 10 10').attr('refX', 10).attr('refY', 5).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto-start-reverse')
        .append('path').attr('d', 'M 0 0 L 10 5 L 0 10 z').attr('fill', '#888');
      linkSel.attr('marker-end', 'url(#arrow)');

      // edge labels
      linkG.selectAll('text.edge-label').data(links)
        .enter().append('text').attr('class', 'edge-label')
        .attr('x', e => (pos.get(e.source).x + pos.get(e.target).x) / 2)
        .attr('y', e => (pos.get(e.source).y + pos.get(e.target).y) / 2 - 6)
        .text(e => edgeLabel(e.kind));

      // draw nodes
      const nodeSel = nodeG.selectAll('g.node').data(nodes).enter().append('g').attr('class', 'node')
        .attr('transform', d => `translate(${pos.get(d.id).x},${pos.get(d.id).y})`)
        .on('mousemove', (ev, d) => { if (!pinned) showTip(d, ev); })
        .on('mouseleave', () => { if (!pinned) hideTip(); })
        .on('click', (ev, d) => pinTooltip(d, ev));

      const labelsOn = true; // labels are always on
      nodeSel.each(function (d) {
        const sel = d3.select(this);
        const fill = typeFill[d.type] || '#fff';
        // Shape by type with color (slightly larger to fit labels inside)
        let maxWidth = 42; let maxLines = 2; // default for circles
        if (d.type === 'process') {
          // diamond via rotated square
          sel.append('rect').attr('x', -16).attr('y', -16).attr('width', 32).attr('height', 32).attr('transform', 'rotate(45)').attr('fill', fill);
          maxWidth = 40; maxLines = 2;
        } else if (d.type === 'artifact') {
          sel.append('rect').attr('x', -32).attr('y', -14).attr('width', 64).attr('height', 28).attr('rx', 4).attr('ry', 4).attr('fill', fill);
          maxWidth = 58; maxLines = 2;
        } else if (d.type === 'vector') {
          const r = 16; const points = [[0, -r], [r * 0.866, -r * 0.5], [r * 0.866, r * 0.5], [0, r], [-r * 0.866, r * 0.5], [-r * 0.866, -r * 0.5]];
          sel.append('polygon').attr('points', points.map(p => p.join(',')).join(' ')).attr('fill', fill);
          maxWidth = 40; maxLines = 2;
        } else {
          sel.append('circle').attr('r', 18).attr('fill', fill);
          maxWidth = 36; maxLines = 2;
        }
        // In-node label (centered, wrapped)
        if (labelsOn) {
          const text = sel.append('text').attr('class', 'label');
          const avgChar = 6.5;
          const estPerLine = Math.max(6, Math.floor(maxWidth / avgChar));
          const lines = wrapLabel(d.id, estPerLine, maxLines);
          const lineH = 12; // px
          const offsetY = -((lines.length - 1) * lineH) / 2;
          lines.forEach((ln, i) => {
            text.append('tspan').attr('x', 0).attr('y', offsetY + i * lineH).text(ln);
          });
        }
      });
    }

    // Split text into up to maxLines, each up to maxChars, with ellipsis on the last line if needed
    function wrapLabel(s, maxChars, maxLines) {
      const words = String(s).split(/\s+/);
      const lines = [];
      let cur = '';
      for (const w of words) {
        const test = cur ? cur + ' ' + w : w;
        if (test.length <= maxChars) { cur = test; }
        else { if (cur) lines.push(cur); cur = w; if (lines.length === maxLines - 1) break; }
        if (lines.length === maxLines - 1 && cur.length > maxChars) break;
      }
      if (cur && lines.length < maxLines) lines.push(cur);
      // If there are leftover words, ellipsize the last line
      const leftover = words.slice(lines.join(' ').split(/\s+/).length).length;
      if (leftover > 0 && lines.length) {
        const last = lines[lines.length - 1];
        lines[lines.length - 1] = (last.length > 1 ? last.slice(0, Math.max(1, maxChars - 1)) : last) + '…';
      }
      return lines.length ? lines : [String(s).slice(0, maxChars - 1) + '…'];
    }

    // Persistent tooltip logic: click to pin, fetch and show details in the tooltip
    let pinned = false; let pinnedNode = null;
    const detailCache = new Map();

    function buildPinnedHtml(d, extract, thumbnail) {
      const src = d.source ? `<div style="margin:6px 0 8px"><a href="${escapeHtml(d.source)}" target="_blank" rel="noopener">Open SOURCE ↗</a></div>` : '<div style="margin:6px 0 8px"><span>No source link</span></div>';
      const img = thumbnail ? `<div class="thumb" style="margin:6px 0 8px"><img alt="thumbnail" src="${escapeHtml(thumbnail)}" style="max-width:260px;border-radius:6px;border:1px solid #333"/></div>` : '';
      const body = `<div class="body" style="max-width:300px;line-height:1.35">${escapeHtml(extract || 'No description.')}</div>`;
      return `
        <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
          <div><b>${escapeHtml(d.id)}</b> <span class="pill">${escapeHtml(d.type)}</span></div>
          <button id="tipCloseBtn" aria-label="Close" style="border:none;background:#333;color:#fff;border-radius:12px;padding:2px 8px;cursor:pointer">×</button>
        </div>
        ${src}
        ${img}
        ${body}
      `;
    }

    function pinTooltip(d, ev) {
      // Toggle if clicking the same node
      if (pinned && pinnedNode && pinnedNode.id === d.id) { unpinTooltip(); return; }
      pinned = true; pinnedNode = d;
      // Position near click and make interactive
      const { x, y } = clampToViewport(ev.clientX + 12, ev.clientY + 12, 320, 420);
      tip.style.left = x + 'px'; tip.style.top = y + 'px'; tip.style.opacity = 1; tip.style.pointerEvents = 'auto';
      const preset = DESCRIPTIONS[d.id] || '';
      // Show immediate skeleton
      tip.innerHTML = buildPinnedHtml(d, preset || 'Loading…', null);
      bindTipClose();
      // Fetch details (cache-aware)
      const key = d.source || d.id;
      if (detailCache.has(key)) { const info = detailCache.get(key); updatePinned(d, preset, info); return; }
      fetchDetails(d).then(info => { detailCache.set(key, info); updatePinned(d, preset, info); })
        .catch(() => { updatePinned(d, preset || 'Description unavailable. Open the SOURCE link for details.', { thumbnail: null, extract: preset }); });
    }

    function updatePinned(d, preset, info) {
      const override = THUMBNAIL_OVERRIDES[d.id];
      const thumb = (override !== undefined) ? override : (info && info.thumbnail) || null;
      const text = preset || (info && info.extract) || '';
      tip.innerHTML = buildPinnedHtml(d, text, thumb);
      bindTipClose();
    }

    function unpinTooltip() { pinned = false; pinnedNode = null; tip.style.opacity = 0; tip.style.pointerEvents = 'none'; }

    function bindTipClose() {
      const btn = document.getElementById('tipCloseBtn');
      if (btn) btn.onclick = (e) => { e.stopPropagation(); unpinTooltip(); };
    }

    function clampToViewport(px, py, w, h) {
      const pad = 8; const maxX = window.innerWidth - w - pad; const maxY = window.innerHeight - h - pad;
      return { x: Math.max(pad, Math.min(px, maxX)), y: Math.max(pad, Math.min(py, maxY)) };
    }

    // Close on background click and Esc
    svg.on('click', (ev) => { if (ev.target && ev.target.tagName === 'svg' && pinned) unpinTooltip(); });
    tip.addEventListener('click', (e) => e.stopPropagation());
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && pinned) unpinTooltip(); });

    async function fetchDetails(d) {
      if (!d.source) return { extract: '', thumbnail: null };
      try {
        const u = new URL(d.source);
        if (u.hostname.includes('wikipedia.org')) {
          // Use Wikipedia REST summary API
          // Extract title from /wiki/Title
          const titlePart = decodeURIComponent(u.pathname.split('/wiki/')[1] || '').replace(/_/g, ' ');
          const api = `https://${u.hostname}/api/rest_v1/page/summary/${encodeURIComponent(titlePart)}`;
          const res = await fetch(api, { headers: { 'Accept': 'application/json' } });
          if (!res.ok) throw new Error('wiki rest error');
          const js = await res.json();
          return { extract: js.extract || '', thumbnail: (js.thumbnail && js.thumbnail.source) || null };
        }
        if (u.hostname.includes('fandom.com')) {
          // Use Fandom MediaWiki API
          const titlePart = decodeURIComponent(u.pathname.split('/wiki/')[1] || '').replace(/_/g, ' ');
          const api = `${u.origin}/api.php?action=query&prop=extracts|pageimages&exintro=1&explaintext=1&pithumbsize=480&format=json&origin=*&titles=${encodeURIComponent(titlePart)}`;
          const res = await fetch(api, { headers: { 'Accept': 'application/json' } });
          if (!res.ok) throw new Error('fandom api error');
          const js = await res.json();
          const pages = js.query && js.query.pages ? Object.values(js.query.pages) : [];
          const page = pages[0] || {};
          const extract = page.extract || '';
          const thumbnail = page.thumbnail && page.thumbnail.source ? page.thumbnail.source : null;
          return { extract, thumbnail };
        }
      } catch (e) {
        // fallthrough to default
      }
      return { extract: '', thumbnail: null };
    }
  </script>
</body>

</html>